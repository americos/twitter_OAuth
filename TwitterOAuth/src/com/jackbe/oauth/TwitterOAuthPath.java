package com.jackbe.oauth;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;

import twitter4j.Status;
import twitter4j.Twitter;
import twitter4j.TwitterFactory;
import twitter4j.auth.AccessToken;

import org.apache.commons.lang.StringEscapeUtils;

import com.jackbe.jbp.jems.client.EMMLUserFunction;



public class TwitterOAuthPath extends EMMLUserFunction {

	/**
	 * @lastModiification 09/14/2011  By JavierLeon@JackBe.com  
	 * @version version 1.1
	 * @author JackBe 	 
	 */
	private static final long serialVersionUID = 1L;
	private static SortedProperties props;
	private static String filename = "twitteraccesstoken.properties";
	private static Twitter twitter;
	private static AccessToken accessToken;
	private static int numberOfAccounts;
	private static HashMap<Integer, Boolean> users;
	private static String initialUserId;
	private static int finalUserIndex;
	private static String propertiesFilePath;

	public static void initialize() throws Exception {
		
		accessToken = null;
		props = new SortedProperties();
		users = new HashMap<Integer, Boolean>();
		twitter = new TwitterFactory().getInstance();
		//props.load(new FileInputStream(filename));
		props.load(new FileInputStream(propertiesFilePath+filename));
		initialUserId = props.getProperty("currentUser");
		if (initialUserId == null) {
			initialUserId = "JackBeIntel1";
		}
		try {
			numberOfAccounts = Integer.parseInt(props
					.getProperty("numberOfAccounts"));
		} catch (Exception e) {
			throw new Exception("numberOfAccounts is not defined in "
					+ filename);
		}
		// System.out.println("numberOfAccounts :" + numberOfAccounts);
	}

	private static void savePropertiesFile() {
		try {
			// props.
			props.store(new FileOutputStream(propertiesFilePath+filename),
					"Auto-generated by com.jackbe.oauth.TwitterOAuth class");
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	// Method for loading the User Access Token
	private static AccessToken loadAccessToken(int userIndex) throws Exception {
		// String useId = props.getProperty("currentUser");

		if (users.containsKey(userIndex) == true) {
			return null;

		} else {
			if (userIndex > numberOfAccounts) {
				return loadAccessToken(1);

			}
			users.put(userIndex, true);

		}

		String useId = "JackBeIntel" + userIndex;
		System.out.println("Retrieving token for user: " + useId);
		String token = props.getProperty(useId + "Token");
		String tokenSecret = props.getProperty(useId + "TokenSecret");


		if ((token == null || tokenSecret == null)
				&& userIndex <= numberOfAccounts) {
			System.out
					.println("*** AccessToken Or TokenSecret Not Found for user: "
							+ useId);
			return loadAccessToken(userIndex + 1);
		}

		String consumerKey = props.getProperty("consumerKey" + userIndex);
		String consumerSecret = props.getProperty("consumerSecret" + userIndex);

		if ((consumerKey == null || consumerSecret == null)
				&& userIndex <= numberOfAccounts) {
			System.out
					.println("consumerKey Or consumerSecret Not Found for user: "
							+ useId);
			return loadAccessToken(userIndex + 1);
		}

		twitter.setOAuthConsumer(consumerKey, consumerSecret);
		finalUserIndex = userIndex;
		// Only update the properties file if the Account change
		if (Integer.parseInt(initialUserId.replaceAll("JackBeIntel", "")) != userIndex) {
			props.put("currentUser", useId);
			savePropertiesFile();
		}
		accessToken = new AccessToken(token, tokenSecret);
		twitter.setOAuthAccessToken(accessToken);
		//System.out.println("Limit: " + twitter.getRateLimitStatus());
		if (twitter.getRateLimitStatus().getRemainingHits() < 1) {
			twitter = new TwitterFactory().getInstance();
			return loadAccessToken(finalUserIndex + 1);
		}
		return accessToken;
	}

	// Method for loading the User Access Token
	private static AccessToken loadAccessToken() throws Exception {
		// Call the last user that was used and stored in the properties file
		// otherwise start with user #1
		int userIndex = 1;
		if (initialUserId != null) {
			userIndex = Integer.parseInt(initialUserId.replaceAll(
					"JackBeIntel", ""));
		}
		return loadAccessToken(userIndex);
	}

	public static String printTwitterFeeds(String user, String propertiesFileFileSystemPath) throws Exception {
		
		propertiesFilePath =  propertiesFileFileSystemPath;
		StringBuilder myItems = new StringBuilder();
		myItems.append("<items>");

		try {

			initialize();

			if (loadAccessToken() == null) {
				return "<error>You have reached the limit of requets for all the "
						+ numberOfAccounts
						+ " accounts Or there are not valid accounts information in "
						+ filename 
						+ " file</error>";
			}

			List<Status> statuses = twitter.getUserTimeline(user);
			//System.out.println("Showing " + user + " timeline.");

			for (Status status2 : statuses) {

				 myItems.append("<item>");
				 myItems.append("<entry>" + StringEscapeUtils.escapeXml(status2.getText()) + "</entry>");				 
				 myItems.append("<source>" + "twitter" + "</source>");
				 myItems.append("<created_time>" + StringEscapeUtils.escapeXml(status2.getCreatedAt().toString())
						 + "</created_time>");
				 myItems.append("<link>" + StringEscapeUtils.escapeXml("http://twitter.com/#!/" + user +
						 "/statuses/"
						 + status2.getId()) + "</link>");
				 myItems.append("<timestamp>" + StringEscapeUtils.escapeXml(status2.getCreatedAt().toString()) +
						 "</timestamp>");
				 myItems.append("</item>");
			}
		} catch (Exception e) {
			return "<error>" + StringEscapeUtils.escapeXml(e.getMessage()) + "</error>";
		}

		myItems.append("</items>");

		return myItems.toString();
	}

	public static void main(String[] args) throws Exception {

		// Printing my Tweets!
		for (int i = 0; i < 1; i++) {
			System.out.println(TwitterOAuthPath.printTwitterFeeds("intel","/Users/javierleon/Projects/twitter_OAuth/"));
		}

	}
}
